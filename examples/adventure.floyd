//??? Add bool empty(COLLECTION)
//??? stdlib needs int find(VECTOR v, f, context)


// PRIMITIVES
////////////////////////////////////////////////////////////////////////////////

//	Player is encoded as an object sitting somewhere in the world, usually in a room.

struct object_t {
	string name

	//	The object cannot be moved or carried
	bool fixed

	//	Notice. Even if player can't put something inside (for example), there can still be objects inside.
	bool player_can_put_inside
	bool player_can_put_ontop
	bool player_can_put_behind
	bool player_can_put_under

	[object_t] inside
	[object_t] ontop
	[object_t] behind
	[object_t] under
}

let null_object = object_t("", false,	false, false, false, false, [], [], [], [])

func object_t make_player(){
	return object_t(
		"player",
		false,

		false, false, false, false,
		[], [], [], []
	)
}

struct room_t {
	string name
	string short_description
	string long_description
	[string: string] exits
	[object_t] objects_in_room
}

struct world_t {
	[string: room_t] rooms
}

struct object_pos_t {
	string room_id
	int index
	string object_key
}

struct player_loc_t {
	object_t player
	string room_id
	int index
}

struct action_result_t {
	string message
	world_t new_world
}


// FEATURES
////////////////////////////////////////////////////////////////////////////////

//	If object isn't found, object_pos_t("", -1, "") is returned
func object_pos_t find_object(world_t world, string object_key){
	let room_keys = get_keys(world.rooms)
	for(r in 0 ..< size(room_keys)) {
		let room = world.rooms[room_keys[r]]
		for(i in 0 ..< size(room.objects_in_room)) {
			let o = room.objects_in_room[i]
			if (o.name == object_key) {
				return object_pos_t(room_keys[r], i, object_key)
			}
		}
	}
	return object_pos_t("", -1, "")
}

func object_t load_object(world_t world, object_pos_t pos){
	return world.rooms[pos.room_id].objects_in_room[pos.index]
}

func int find_object_key([object_t] objects, string key){
	for(i in 0 ..< size(objects)){
		if(objects[i].name == key){
			return i
		}
	}
	return -1
}


//	??? optional-feature would be helpful.
func player_loc_t find_player(world_t world){
	let pos = find_object(world, "player")
	if(pos.room_id != ""){
		let object = load_object(world, pos)
		return player_loc_t(object, pos.room_id, pos.index)
	}
	else{
		return player_loc_t(null_object, "", -1)
	}
}


func world_t remove_object(world_t world, object_pos_t pos){
	let objects = world.rooms[pos.room_id].objects_in_room
	let index = find_object_key(objects, pos.object_key)
	assert(index != -1)

	let [object_t] empty = []
	let objects2 = replace(objects, index, index + 1, empty)
	let room2 = update(world.rooms[pos.room_id], objects_in_room, objects2)
	let rooms2 = update(world.rooms, pos.room_id, room2)
	return world_t(rooms2)
}

func world_t append_object(world_t world, string room_id, object_t object){
	let objects2 = push_back(world.rooms[room_id].objects_in_room, object)
	let room2 = update(world.rooms[room_id], objects_in_room, objects2)
	let rooms2 = update(world.rooms, room_id, room2)
	return world_t(rooms2)
}


func world_t move_object_to_room(world_t world, object_pos_t source_pos, string dest_room_id, object_t object){
	let world2 = remove_object(world, source_pos)
	let world3 = append_object(world2, dest_room_id, object)
	return world3
}

func bool nonplayer(object_t object, int context){
	return object.name != "player"
}

func string action_look(world_t world){
	let player_loc = find_player(world)
	assert(player_loc.player.name == "player")
	assert(player_loc.room_id != "" && player_loc.index != -1)

	let room = world.rooms[player_loc.room_id]
	let desc = room.long_description

	let objects = filter(room.objects_in_room, nonplayer, 0)
	if(size(objects) > 0){
		mutable acc = ""
		for(i in 0 ..< size(objects)){
			acc = acc + "\t" + objects[i].name + "\n"
		}
		return desc + "\n" + acc
	}
	else{
		return desc
	}
}

func action_result_t action_go(world_t world, [string] words){
	assert(size(words) >= 1)
	if(size(words) != 2){
		return action_result_t("I don't understand that sentence.", world)
	}

//	print("world0: " + to_pretty_string(world))

	let dir = words[1]

	let player_loc = find_player(world)

	assert(player_loc.player.name == "player")
	assert(player_loc.room_id != "" && player_loc.index != -1)


	let room = world.rooms[player_loc.room_id]
	if(exists(room.exits, dir) == false){
		return action_result_t("You hit a wall.", world)
	}
	else {
		let dest_room_id = room.exits[dir]
		let player_loc = find_player(world)
		let source_pos = object_pos_t(player_loc.room_id, player_loc.index, player_loc.player.name)
		let world2 = move_object_to_room(world, source_pos, dest_room_id, player_loc.player)

		let message = action_look(world2)
		return action_result_t(message, world2)
	}

	return action_result_t("You can't go there!", world)
}

func bool string_not_empty(string s, int context){
	return size(s) > 0
}

//??? Add stdlib split-function
//	returns 0...many strings. All leading/trailing spaces are removed. All returned entries are non-empty
func [string] words_from_string(string s){
	mutable [string] words = []
	mutable pos = 0
	mutable acc = ""
	while(pos < size(s)){
		let ch = s[pos]
		if(ch == ' '){
			words = push_back(words, acc)
			acc = ""
		}
		else{
			acc = push_back(acc, ch)
		}
		pos = pos + 1
	}
	words = push_back(words, acc)

	return filter(words, string_not_empty, 0)
}

assert(words_from_string("") == [])
assert(words_from_string("hello") == ["hello"])
assert(words_from_string("hello world") == ["hello", "world"])
assert(words_from_string("   hello   world   ") == ["hello", "world"])


////////////////////////////////////////////////////////////////////////////////

let k_shortcuts = {
	"l": "look",

	"n": "go north",
	"ne": "go northeast",
	"e": "go east",
	"se": "go southeast",
	"s": "go south",
	"sw": "go southwest",
	"w": "go west",
	"nw": "go northwest",

	"up": "go up",
	"down": "go down"
}

func action_result_t execute_command(world_t world, string command){
	if(exists(k_shortcuts, command)){
		return execute_command(world, k_shortcuts[command])
	}

	let words = words_from_string(command)
	if(size(words) > 0){
		let verb = words[0]
		if(verb == "look"){
			if(size(words) != 1){
				return action_result_t("I don't know how to look that way!", world)
			}
			else{
				return action_result_t(action_look(world), world)
			}
		}
		else if(verb == "go"){
			return action_go(world, words)
		}
		else if(verb == "take"){

		}
		else if(verb == "graph"){
			return action_result_t(to_pretty_string(world), world)
		}
		else {
		}
	}
	return action_result_t("", world)
}



// GAME CONTENTS
////////////////////////////////////////////////////////////////////////////////



let init_world = world_t(
	{
		"forest-small-clearing": room_t (
			"Small clearing",
			"You are in a small clearing.",
			"You are in a small clearing in a pine forest. It's sunny and birds are singing. There is a path to the east.",
			{ "east": "forest-path2" },
			[
				make_player()
			]
		),

		"forest-path2": room_t (
			"Forest path",
			"You are on the muddy path.",
			"This is a muddy path heading north-sound up a small hill. Further westward the forest opens up.",
			{ "west": "forest-small-clearing", "up": "forest-hill", "north": "forest-hill" },
			[
				object_t("chest", false,		false, false, false, false, [], [], [], [])
			]
		),

		"forest-hill": room_t (
			"Forest hill",
			"You are on the forest hill.",
			"You are on the forest hill, looking out over a forest stretching out around you.",
			{ "south": "forest-path2", "down": "forest-path2" },
			[
				object_t("key", false,		false, false, false, false, [], [], [], []),
				object_t("tree", true,		false, false, false, false, [], [], [], [])
			]
		)
	}
)


////////////////////////////////////////////////////////////////////////////////


print("Welcome to the the dungeon!")

mutable world_acc = init_world
print("You look around: " + action_look(world_acc))

mutable quit = false
while(quit == false){
	print(">")
	let a = read_line_stdin()
	if(a == "q" || a == "quit"){
		print("Bye!")
		quit = true
	}
	else{
		let r = execute_command(world_acc, a)

//		print("BEFORE: " + to_pretty_string(world_acc))
//		print("AFTER: " + to_pretty_string(r))

		let output = r.message == "" ? "Nothing happens." : r.message
		print(output)

		world_acc = r.new_world
	}
}

